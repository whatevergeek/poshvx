<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AlreadyInstalled" xml:space="preserve">
    <value>Package '{0}' is already installed.</value>
  </data>
  <data name="CompletedDownload" xml:space="preserve">
    <value>Completed downloading '{0}'.</value>
  </data>
  <data name="CompletedIterating" xml:space="preserve">
    <value>Completed iterating for '{0}'.</value>
  </data>
  <data name="CouldNotGetResponseFromQuery" xml:space="preserve">
    <value>Could not get response from query '{0}'.</value>
  </data>
  <data name="CreateDirectory" xml:space="preserve">
    <value>Create directory '{0}'.</value>
  </data>
  <data name="CreateFile" xml:space="preserve">
    <value>Create a file '{0}'.</value>
  </data>
  <data name="DebugInfoCallMethod" xml:space="preserve">
    <value>Calling '{0}'::'{1}'.</value>
  </data>
  <data name="DebugInfoCallMethod3" xml:space="preserve">
    <value>Calling '{0}'::'{1}', '{2}'.</value>
  </data>
  <data name="DebugInfoReturnCall" xml:space="preserve">
    <value>Returning the call '{0}'::'{1}'.</value>
  </data>
  <data name="DependencyLoopDetected" xml:space="preserve">
    <value>Dependency loop detected for package '{0}'.</value>
  </data>
  <data name="Downloading" xml:space="preserve">
    <value>Downloading ...</value>
  </data>
  <data name="FailedDownloadPackage" xml:space="preserve">
    <value>'{0}': Downloading package '{1}' failed, please make sure '{1}' is accessable.</value>
  </data>
  <data name="FileNotFound" xml:space="preserve">
    <value>File '{0}' does not exist in '{1}'.</value>
  </data>
  <data name="FoundRegisteredSource" xml:space="preserve">
    <value>Source '{0}' is one of the registered sources in '{1}' provider.</value>
  </data>
  <data name="FoundTotalRegisteredSource" xml:space="preserve">
    <value>Found '{0}' registered package source in '{1}' provider.</value>
  </data>
  <data name="HashNotFound" xml:space="preserve">
    <value>Hash not found for the package '{0}'.</value>
  </data>
  <data name="HashNotMatch" xml:space="preserve">
    <value>Hash for package '{0}' does not match hash provided from the server.</value>
  </data>
  <data name="HashNotSupported" xml:space="preserve">
    <value>Hash algorithm '{0}' is not supported.</value>
  </data>
  <data name="HeaderIgnored" xml:space="preserve">
    <value>Provided header value '{0}' was invalid and hence ignored.</value>
  </data>
  <data name="InvalidFileExtension" xml:space="preserve">
    <value>The file extension '{0}' is not valid. The required file extension is '.nupkg'.</value>
  </data>
  <data name="InvalidPackage" xml:space="preserve">
    <value>The package '{0}' does not have the .nuspec file.</value>
  </data>
  <data name="InvalidQueryUrl" xml:space="preserve">
    <value>Query Url {0} is invalid.</value>
  </data>
  <data name="InvalidVersionString" xml:space="preserve">
    <value>'{0}' is not a valid version string.</value>
  </data>
  <data name="LoadedConfigurationFile" xml:space="preserve">
    <value>Loaded a configuration from file '{0}'.</value>
  </data>
  <data name="LoadingConfigurationFile" xml:space="preserve">
    <value>Loading a configuration from file '{0}'.</value>
  </data>
  <data name="MissingConfigurationElement" xml:space="preserve">
    <value>Configuration file '{0}' does not have 'configuration' element.</value>
  </data>
  <data name="NoPackageFound" xml:space="preserve">
    <value>'{0}': No package found.</value>
    <comment>0 - provider name</comment>
  </data>
  <data name="FailToInstallPackage" xml:space="preserve">
    <value>'{0}': Failed to install Package '{1}'.</value>
    <comment>0 - provider name. 1 - package name</comment>
  </data>
  <data name="NotFoundRegisteredSource" xml:space="preserve">
    <value>Source '{0}' is not one of the registered sources in '{1}' provider.</value>
  </data>
  <data name="PackageFailedInstall" xml:space="preserve">
    <value>Package '{0}' failed to install.</value>
  </data>
  <data name="PackagesReceived" xml:space="preserve">
    <value>'{0}' packages recevied in the last request.</value>
  </data>
  <data name="ProviderNotFound" xml:space="preserve">
    <value>A required provider '{0}' does not exist. Try 'Find-PackageProvider' and 'Install-PackageProvider' to install the particular provider.</value>
    <comment>0 - provider name</comment>
  </data>
  <data name="RegisteredSources" xml:space="preserve">
    <value>There are '{0}' registered sources in '{1}' provider.</value>
  </data>
  <data name="RemovedPackageSource" xml:space="preserve">
    <value>Removed the package source: '{0}'.</value>
  </data>
  <data name="RequestCanceled" xml:space="preserve">
    <value>Request is canceled in '{0}'::'{1}'.</value>
  </data>
  <data name="SavingConfigurationWithFile" xml:space="preserve">
    <value>Saving a config with a file path '{0}'.</value>
  </data>
  <data name="SearchingRepository" xml:space="preserve">
    <value>Searching repository '{0}' for '{1}'.</value>
  </data>
  <data name="SettingConfigurationToNull" xml:space="preserve">
    <value>Setting a config object to null.</value>
  </data>
  <data name="SkippedDownloadedPackage" xml:space="preserve">
    <value>Skipping Downloaded Package '{0}'.</value>
  </data>
  <data name="SourceIsADirectory" xml:space="preserve">
    <value>Source '{0}' is a directory.</value>
  </data>
  <data name="SourceIsAFilePath" xml:space="preserve">
    <value>Source '{0}' is a file path.</value>
  </data>
  <data name="SuccessfullyDownloaded" xml:space="preserve">
    <value>Package '{0}' is downloaded.</value>
  </data>
  <data name="SuccessfullyInstalled" xml:space="preserve">
    <value>Package '{0}' is installed.</value>
  </data>
  <data name="SuccessfullyValidated" xml:space="preserve">
    <value>Source '{0}' is validated.</value>
  </data>
  <data name="TotalPackageYield" xml:space="preserve">
    <value>Total package yield:'{0}' for the specified package '{1}'.</value>
  </data>
  <data name="TypeMustBeASemanticVersion" xml:space="preserve">
    <value>Type to compare must be an instance of SemanticVersion.</value>
  </data>
  <data name="UnableToInstallPackage" xml:space="preserve">
    <value>The package '{0}' failed to install.</value>
  </data>
  <data name="UnableToResolveDependency" xml:space="preserve">
    <value>Unable to resolve package dependency -- package '{0}' not found.</value>
  </data>
  <data name="UnableToResolveSource" xml:space="preserve">
    <value>'{0}':Unable to resolve package source '{1}'.</value>
  </data>
  <data name="UnexpectedFileType" xml:space="preserve">
    <value>The file extension '{0}'::'{1}' is not valid. The required file extension is '.nuspec' or '.nupkg'.</value>
  </data>
  <data name="UninstalledPackage" xml:space="preserve">
    <value>Uninstalled '{0}' package.</value>
  </data>
  <data name="UnkownCategory" xml:space="preserve">
    <value>Unknown category for '{0}'::'{1}': '{2}'</value>
  </data>
  <data name="UriSchemeNotSupported" xml:space="preserve">
    <value>Uri Scheme '{0}' is not supported. Only '{1}' is supported.</value>
  </data>
  <data name="UseDefaultConfig" xml:space="preserve">
    <value>Use the default configuration.</value>
  </data>
  <data name="VariableCheck" xml:space="preserve">
    <value>'{0}' is '{1}'.</value>
  </data>
  <data name="WildCardCharsAreNotSupported" xml:space="preserve">
    <value>The parameter Name '{0}' is required and cannot contain wildcard characters when RequiredVersion, MinimumVersion or MaximumVersion is specified in the same command.</value>
    <comment>0 - name</comment>
  </data>
  <data name="Yielding" xml:space="preserve">
    <value>Yielding.</value>
  </data>
  <data name="YieldingPackageSource" xml:space="preserve">
    <value>Yielding the package source: '{0}'.</value>
  </data>
  <data name="BytesRead" xml:space="preserve">
    <value>Number of bytes read: '{0}'</value>
    <comment>0 - a number</comment>
  </data>
  <data name="CallMsiForInstall" xml:space="preserve">
    <value>Calling Msi provider to install the package '{0}'</value>
  </data>
  <data name="CannotFindManifestFile" xml:space="preserve">
    <value>'{0}': PackageManagement manifest file '{1}' does not exist in '{2}'.</value>
  </data>
  <data name="CannotFindPackage" xml:space="preserve">
    <value>'{0}': cannot find packages with a canonicalId = '{1}'.</value>
  </data>
  <data name="CannotFindPackageManagementVersion" xml:space="preserve">
    <value>Cannot identify the PackageManagement version. Try 'Get-Module -Name PackageManagement -ListAvailable' to check if the PackageManagement is available.</value>
  </data>
  <data name="DependencyInstalled" xml:space="preserve">
    <value>The dependency package '{0}' is already installed.</value>
  </data>
  <data name="DependencyNotInstalled" xml:space="preserve">
    <value>The dependency package '{0}' is not installed.</value>
  </data>
  <data name="DirectoryNotExist" xml:space="preserve">
    <value>'{0}': Directory '{1}' does exist.</value>
  </data>
  <data name="DownloadingPackage" xml:space="preserve">
    <value>Downloading a package '{0}' ...</value>
    <comment>0 - package name</comment>
  </data>
  <data name="DownloadingProgress" xml:space="preserve">
    <value>Downloaded {0:0.00} MB out of {1:0.00} MB.</value>
  </data>
  <data name="FailedToDownload" xml:space="preserve">
    <value>'{0}': Failed to download a package from '{0}' and save it to '{1}'. Try re-run the cmdlet with -verbose -debug to get more information.</value>
    <comment>0 - package url; 1- file path</comment>
  </data>
  <data name="FailedToGetPackageObject" xml:space="preserve">
    <value>'{0}': failed to get a package from the given fast reference '{1}.</value>
    <comment>0 - package provider name, 1 - path</comment>
  </data>
  <data name="FoundMorePackages" xml:space="preserve">
    <value>'{0}': found more than one package ('{1}') with a canonicalId = '{2}'. Please double check if package name, version, and source location are correct.</value>
  </data>
  <data name="InstallFailed" xml:space="preserve">
    <value>Failed to install the package '{0}' , see error details: '{1}'.</value>
  </data>
  <data name="Installing" xml:space="preserve">
    <value>Installing ...</value>
  </data>
  <data name="InstallingPackage" xml:space="preserve">
    <value>Installing a package from '{0}'</value>
  </data>
  <data name="MininumVersonCheck" xml:space="preserve">
    <value>Provider '{0}' is not used to perform this operation because it requires a minimum version of the PackageManagement module to be '{1}', but the current version of the PackageManagement module is '{2}'.</value>
  </data>
  <data name="NumberOfPackagesRecevied" xml:space="preserve">
    <value>'{0}' packages returned by the provider '{1}' for the '{2}' operation.</value>
  </data>
  <data name="RetryingDownload" xml:space="preserve">
    <value>Retry downloading '{0}' for '{1}' more times</value>
  </data>
  <data name="RunningCommand" xml:space="preserve">
    <value>Running command '{0}'</value>
  </data>
  <data name="UninstallFailed" xml:space="preserve">
    <value>Uninstall operation failed by running a command '{0}' , see error details: '{1}'.</value>
  </data>
  <data name="Uninstalling" xml:space="preserve">
    <value>UnInstalling a package ...</value>
  </data>
  <data name="UninstallingPackage" xml:space="preserve">
    <value>'{0}': uninstalling package '{1}'.</value>
  </data>
  <data name="UnknownMediaType" xml:space="preserve">
    <value>Package '{0}' with Source '{1}' has unknown media type '{2}'.</value>
  </data>
  <data name="UnsuportedUriFormat" xml:space="preserve">
    <value>The provider '{0}' does not support the Uri format: '{1}'.</value>
  </data>
  <data name="UnsupportedPackageSource" xml:space="preserve">
    <value>Unsupported package source '{0}'.</value>
  </data>
  <data name="UnsupportedProviderType" xml:space="preserve">
    <value>'{0}': provider type '{0}' not supported.</value>
  </data>
  <data name="UnsupportMSIUninstall" xml:space="preserve">
    <value>'{0}' does not support uninstalling '{1}'. Try use -providerName msi.</value>
  </data>
  <data name="CannotConvertGenericTypes" xml:space="preserve">
    <value>Cannot convert type with more than 2 generic arguments</value>
  </data>
  <data name="CannotConvertObject" xml:space="preserve">
    <value>Cannot convert object of type '{0}' to primitive, string or PSObject type.</value>
  </data>
  <data name="InvalidPackageListFormat" xml:space="preserve">
    <value>Package List Source '{0}' has incorrect format.</value>
  </data>
  <data name="QueryDownloadPackageSourceList" xml:space="preserve">
    <value>Do you want to download package source list from '{0}'?</value>
    <comment>0 - source list path</comment>
  </data>
  <data name="FileExists" xml:space="preserve">
    <value>A file with this name already exists in target directory</value>
  </data>
  <data name="OverwriteFile" xml:space="preserve">
    <value>Do you want to overwrite it?</value>
  </data>
  <data name="PackageSourceListNotTrusted" xml:space="preserve">
    <value>PackageSourceList is not trusted</value>
  </data>
  <data name="VersionNotFound" xml:space="preserve">
    <value>Package '{0}' in json file '{1}' is missing version information.</value>
  </data>
  <data name="HashNotSpecified" xml:space="preserve">
    <value>Invalid hash for package '{0}'. Please correct the values in json file or use -SkipHashValidation switch to skip Hash validation.</value>
  </data>
  <data name="HashValidationSuccessfull" xml:space="preserve">
    <value>Hash validation was successful.</value>
  </data>
  <data name="HashVerificationFailed" xml:space="preserve">
    <value>Hash verification failed for package '{0}' downloaded from '{1}'.</value>
  </data>
  <data name="InvalidHashAlgorithm" xml:space="preserve">
    <value>Hash algorithm '{0}' is not supported. We only support sha512, md5 and sha256.</value>
  </data>
  <data name="SkipHashValidation" xml:space="preserve">
    <value>Skipping Hash Validation.</value>
  </data>
  <data name="CatalogFileMissing" xml:space="preserve">
    <value>Catalog file not found for '{0}'. Catalog files are required for non local json files and should have the same name and located in the same directory as json file.</value>
  </data>
  <data name="CatalogFileVerificationFailed" xml:space="preserve">
    <value>Catalog File verification failed for  '{0}'.</value>
  </data>
  <data name="CatalogFileVerificationFailedWithError" xml:space="preserve">
    <value>Catalog File '{0}' verification failed with '{1}'.</value>
  </data>
  <data name="PackageSourceListNotFound" xml:space="preserve">
    <value>Cannot find source list file '{0}'.</value>
  </data>
  <data name="PackageSourceManifestNotFound" xml:space="preserve">
    <value>File '{0}' is registered as a package source location for the provider '{1}'. But it does not exist. Run 'Get-PackageSource' to view the registered package sources, 'Unregister-PackageSource' to unregister the source if you do not wish to use it or 'Set-PackageSource' to fix the source location.</value>
  </data>
</root>